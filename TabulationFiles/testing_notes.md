# Andrew's Notes

This file records testing, timings, and other things I want to remember like scripting commands.

# Small Tabulations and Timings

While the project is designed for B = 10^24 only, there is of course a need to do smaller tabulations for timings and other checks.  The file for this is small_tabulation.cpp, which compiles to the executable small_tab.  This file combines work found in precomputation.cpp and Preproduct.cpp into a single serial computation.  These runs were performed with the following steps (deprecated).  

* Set B_pow.  The upper bound B will be 10 to this power.  Note X is automatically set to B^{1/3}.
* In Preproduct.cpp, make sure the #define TEST preprocessing flag is set
* In Preproduct.cpp constructor, set the testing bound to the same value as B_pow
* In Preproduct::CN_multiples_of_P, set the testing value for X to B^{1/3}
* In that same function, just above definition of X, you can choose a flag for early abort or not.  [More details needed]

Now compile and run small_tab.  To do comparisons of files, it is a good idea to sort and remove duplicates.  For example, 

sort -u -n -k1 cars_large10to15.txt > cars15_sorted.txt

Once again, the steps above are deprecated.  The TEST preprocessing flag is no longer part of the codebase.  If interested in reproducing small tabulations, see comment at the top of Preproduct.cpp about hardcoded values of B and X.

In any case, December 2025 I performed the steps above and generated serial tabulations.  I did this for B = 10^k for k = 14, 15, 16, 17, 18.  In each case X was set to B^{1/3}.  I focused on the large case only, so generating Carmichaels with P_{d-2} > X and n < B.  I compared timings and outputs to lists of Carmichaels generated by the old codebase.  In each case the old codebase list was a subset of the new codebase list, i.e. the new codebase was never missing any Carmichaels.  I had to remove repeats from lists generated by both codebases.  The new codebase has a larger list of cars because I couldn't strictly set P_{d-2} > X, generating something closer to P > X where P is an arbitrary preproduct of the eventual Carmichael n.

Here is the resulting table of timings, also found in the paper.  Timings in seconds.  The old codebase used a prime-by-prime tabulation strategy with single prime completions, the new codebase uses a composite completion strategy.  Again, these timings are for serial tabulations.  We think the new codebase does a better job at parallelization also, but that hasn't yet been measured.  Also note that the old codebase timings use the slower admissibility checks with gcds, because that was what we did in generating our 10^22 table.

| B | Old Codebase | New Codebase |
|---|--------------|--------------|
| 10^14 | 64 | 140 |
| 10^15 | 397 | 711 | 
| 10^16 | 2456 | 3631 |
| 10^17 | 15361 | 18352 |
| 10^18 | 95476 | 92891 |

The files generated are found in folder SerialTestFiles.  Files with suffix "old" are from the old codebase.  Files with suffix "true" or "false" refer to the new codebase, with early abort turned either on or off.  The false files (no early abort) were generally a closer match, but significantly slower, so for 10^17 and 10^18 I only generated files with early abort turned on.

## Admissibility Checks

Kudos to Jonathan Webster for noticing this.  It's a simple thing, but it makes a big difference.  This was implemented in the new codebase, so for timings I went to the old codebase.  In prime-by-prime generation of preproducts, we want to skip over inadmissible ones, and only consider admissible preproducts.  My first way of implementing this looked like this:

```
do{
    i3++;
    q = primes[i3];
}while( gcd( q - 1, P2 ) != 1 );
P3 = P2 * q; 
```

While a gcd is cheap compared to searching for carmichaels, it is more expensive than a division.  Here's the new way:
```
do{ q = primes[ ++i3 ]; } while( q % p1 == 1 || q % p2 == 1 );
P3 = P2 * q; 
```
Note we are utilizing the fact that q is greater than both p1, p2, and that P2 is the squarefree product of p1 and p2.

I performed serial timings of the large case (i.e. preproduct P_{d-2} > X) for several B values, where X = B^{1/3}.  Timings in seconds.
| B | Old Admissibility | New Admissibility |
|---|--------------|--------------|
| 10^14 | 64 | 49 |
| 10^15 | 397 | 309 | 
| 10^16 | 2456 | 1923 |
| 10^17 | 15361 | 11951 |
| 10^18 | 95476 |  |

## Early Abort Timings

Timings in seconds, with the new codebase, serial timings, early abort flag turned off or on, line 128 of Preproduct.cpp.
| B | No Early Abort | Early Abort |
|---|--------------|--------------|
| 10^14 | 433 | 142 |
| 10^15 | 2707 | 726 | 
| 10^16 | 16980 | 3699 |
| 10^17 |  | 18550 |
| 10^18 |  | 92891 |
